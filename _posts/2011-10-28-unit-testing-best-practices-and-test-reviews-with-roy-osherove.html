---
layout: post
title: "Unit Testing Best Practices and Test Reviews with Roy Osherove"
date: 2011-10-28 10:58:02
categories: .net testing
---
<p>
Yesterday I attended a session on unit testing by <a href="http://osherove.com/">Roy Osherove</a> in Copenhagen. As I am trying to learn more about unit testing and TDD by applying it in a pet project, it was very interesting to see what a veteran like Roy had to say about the subject of unit testing. Also very interesting was his approach in this session, as he tried to teach us about good habits by showing us bad (real world) examples.
</p>
<p>
He also pointed out that anyone interested in writing unit tests and working test driven should do test reviews. It can be used as a learning tool, for example test review some open source projects. But it can also be used internally almost as a replacement of code reviews, because reviewing tests takes a lot less time and should give you a good idea of what the code is supposed to do (when working test driven).
</p>
<p>
I took some notes during the session that I would like to share - and keep here for my own reference ;-) I wrote down most of his tips, so to the unit testing experts out there some of it might seem really basic. But I thought it was interesting to have it all written down.
</p>

<h2>Three important words</h2>
The basic, yet very important requirements for tests:
<ul>
	<li><strong>Readable</strong></li>
	<li><strong>Maintainable</strong></li>
	<li><strong>Trustworthy</strong></li>
</ul>

<h2>Unit test VS integration test</h2>
<p>
Unit tests are used for testing stuff in memory. The tests don’t change and they’re static. They don’t depend on other things.
</p>
<p>
Integration tests would be used when there is a dependency on the filesystem, a database, a Sharepoint server, etc.
</p>
<p>
Unit tests and integration tests have their own testproject!
</p>

<h2>Basics</h2>
<ul>
	<li>Avoid test logic: too complicated
<ul>
	<li>Ifs, switches, for loops, ..</li>
</ul>
</li>
	<li>No multiple asserts
<ul>
	<li>This can be okay when you’re asserting using the same object</li>
</ul>
</li>
	<li>Avoid “magic numbers”
<ul>
	<li>Using the number 42 somewhere raises the question whether it is important that the number is equal to 42; a good idea would be to use a variable with a descriptive name</li>
</ul>
</li>
	<li>Don’t assert on calculations or concatenations
<ul>
	<li>Assert(“user,password”, Bleh()) is better than Assert(user + “,” + password, Bleh())</li>
</ul>
</li>
	<li>Don’t change or remove tests!</li>
	<li>DateTime.Now (or friends like Random) –&gt; NOT okay! These values change everytime</li>
	<li>Test only publics</li>
</ul>

<h2>Reuse</h2>
<ul>
	<li>Factory methods (usually in the same class as the tests using them)
<ul>
	<li>make_xx</li>
</ul>
</li>
	<li>Configure initial state
<ul>
	<li>init_xx</li>
</ul>
</li>
	<li>Common tests in common methods
<ul>
	<li>verify_xx</li>
</ul>
</li>
</ul>

<h2>Tests are isolated</h2>
<ul>
	<li>Don’t call other tests in a test</li>
	<li>No shared state, have cleanup code for shared objects</li>
</ul>
<h2>Mock != Stub (in short)</h2>
<ul>
	<li>Mock = used for asserts</li>
	<li>Stub = used to help the test</li>
	<li>Fake = can be both</li>
</ul>

<h2>Tip</h2>
<p>
If you need to test things related to a database, that would be an integration test and it’s a good idea to use the TransactionScope class in .NET so you can rollback everything when the test is done.
</p>
