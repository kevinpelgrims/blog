---
layout: post
title: "Parallel programming in .NET - PLINQ"
date: 2011-12-23 06:02:00
categories: parallel .net
---
<p>
Now that we've covered the <a title="Parallel programming in .NET – Task Parallel Library" href="http://kevinpelgrims.com/blog/2011/12/16/parallel-programming-in-net-task-parallel-library/">Task Parallel Library</a>, it's time to move on.
</p>

<h2>What is PLINQ?</h2>
<p>
PLINQ stands for Parallel LINQ and is simply the parallel version of LINQ to Objects. Just like LINQ you can use it on any IEnumerable and there’s also deferred execution. Using PLINQ is even easier than using the Task Parallel Library!
</p>

<div class="imagecaption" style="width: 300px;">
 <a href="http://kevinpelgrims.com/blog/get/images/2011/12/parallel_net_plinq.png"><img title="PLINQ" src="http://kevinpelgrims.com/blog/get/images/2011/12/parallel_net_plinq.png" alt="" width="300" height="129" /></a>
 <br /><span class="caption">Regular for loop and LINQ compared to PLINQ (with time in seconds)</span>
</div>

<h2>How do we use PLINQ?</h2>
<p>
You can even make existing LINQ queries parallel simply by adding the <span style="font-family:'Courier New';">AsParallel()</span> method. That’s how easy it is! This makes it easy to use the power of parallelization, while enjoying the readability of LINQ. Isn’t that great?
</p>

<pre class="prettyprint">
var employees = GetEmployees();

// Regular LINQ
var query = employees.Select(e =&gt; e.Skills.Contains(&quot;C#&quot;));

// Extension method style PLINQ
var queryParallel1 = employees.AsParallel()
                              .Select(e =&gt; e.Skills.Contains(&quot;C#&quot;));

// Query expression style PLINQ
var queryParallel2 = from e in employees.AsParallel()
                     where e.Skills.Contains(&quot;C#&quot;)
                     select e;
</pre>

<p>
Important fact: PLINQ uses all the processors of your system by default, with a maximum of 64. In some cases you might want to limit this, to give a machine some more power to take care of other tasks. Everybody deserves some CPU time! So don’t be greedy and use <span style="font-family:'Courier New';">WithDegreeOfParallelism()</span> on heavy queries. Following example uses a maximum of 3 processors, even if there are 16 available.
</p>

<pre class="prettyprint">
var queryDegree = employees.AsParallel()
                           .WithDegreeOfParallelism(3)
                           .Select(e =&gt; e.Skills.Contains(&quot;C#&quot;));
</pre>

<p>
By default PLINQ doesn’t care about the order of your output, compared to the input. This is because order preservation costs more time. You can enable order preservation though, again in a very simple way, by using the <span style="font-family:'Courier New';">AsOrdered()</span> method. It’s good to know that <span style="font-family:'Courier New';">OrderBy()</span> will also take care of order preservation.
</p>

<pre class="prettyprint">
var employees = GetEmployeesOrderedByName();

var queryOrdered = employees.AsParallel()
                            .Select(e =&gt; e.Skills.Contains(&quot;C#&quot;))
                            .AsOrdered();
</pre>

<h2>We want more!</h2>
<p>
PLINQ has a lot more to offer than what we talked about here, so be sure to use Google and MSDN if you want to know more. Check out this "old" (2007) yet interesting <a title="Running Queries On Multi-Core Processors" href="http://msdn.microsoft.com/en-us/magazine/cc163329.aspx">article on PLINQ</a> from MSDN magazine. An important read is <a href="http://msdn.microsoft.com/en-us/library/dd997399.aspx">Understanding Speedup in PLINQ on MSDN</a>, which explains a bit more of how PLINQ works and why it sometimes defaults to sequential mode anyway.
</p>
